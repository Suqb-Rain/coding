#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cstring>
#include <vector>
#include <functional>

using std::vector;
using std::pair;

#define ll long long


#pragma region io_debug
#define cpp11
namespace fastio {
    #define ffileio
    #ifdef ffileio
        const int ms = (1 << 20);
        char buf[ms], *p1 = buf, *p2 = buf, pbuf[ms], *pp = pbuf;
        inline char getchar() {
            return (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, ms, stdin), p1 == p2)) ? EOF : *p1 ++;
        }
        inline void putchar(char ch) {
            *pp ++ = ch;
            if (pp == pbuf + ms) fwrite(pbuf, 1, ms, stdout), pp = pbuf;
        }
    #endif

    template<class T>
    inline void read(T &x, char ch = getchar()) {
        x = 0;
        int flg = 1;
        for (; !isdigit(ch); ch = getchar()) if (ch == '-') flg = -1;
        for (; isdigit(ch); x = x * 10 + ch - 48, ch = getchar());
        x *= flg;
    }
    template<class T>
    inline T read_re(T SIGN = 0, char ch = getchar()) {
        T x = 0;
        int flg = 1;
        for (; !isdigit(ch); ch = getchar()) if (ch == '-') flg = -1;
        for (; isdigit(ch); x = x * 10 + ch - 48, ch = getchar());
        return x * flg;
    }

    #ifdef cpp11
        template<class First, class... Rest>
        inline void read(First& fir, Rest&... rest) {
            read(fir), read(rest...);
        }
    #endif

    template<class T>
    inline void write(T x, char ch = '\n') {
        static int sta[35];
        int top = 0;
        if (x < 0) putchar('-'), x = -x;
        do {
            sta[++ top] = x % 10;
            x /= 10;
        } while (x);
        while (top) putchar(sta[top --] + 48);
        putchar(ch);
    }

    #ifdef cpp11
        template<class First, class... Rest>
        inline void write(First fir, Rest... rest) {
            write(fir), write(rest...);
        }
    #endif
} using namespace fastio;

namespace DEBUG {
    template<class T>
    inline void _debug(const char *ch, T x) {
        std::cerr << ch << " = " << x << std::endl;
    }

    #ifdef cpp11
        template<class First, class... Rest>
        inline void _debug(const char *ch, First fir, Rest... rest) {
            while (*ch != ',') std::cerr << *ch ++;
            std::cerr << " = " << fir << ",";
            _debug(ch + 1, rest...);
        }
    #endif

    template<class T>
    std::ostream &operator<<(std::ostream &os, const std::vector<T> &vec) {
        os << '[';

        #ifdef cpp11
            for (auto v : vec) {
                os << v << ", ";
            }
        #else 
            int siz = vec.siz();
            for (register int i = 0; i < siz; ++ i) {
                os << vec[i] << ", ";
            }
        #endif
        os << ']';
        return os;
    }

    #ifdef cpp11
        #define debug(...) _debug(#__VA_ARGS__, __VA_ARGS__), putchar('\n');
    #endif
    // 第一个是把 "参数" 转化为字符串方便输出  第二个就是实打实传参
} using namespace DEBUG;
#pragma endregion io_debug

const int md = 998244353, gen[] = {3, (md + 1) / 3}, MAXL = (1 << 20);

#pragma region _operator
inline ll ad(ll a, ll b, ll mod = md) { (a += b) >= mod && (a -= mod); return a; }
inline ll su(ll a, ll b, ll mod = md) { (a -= b) < 0 && (a += mod); return a; }
inline ll mul(ll a, ll b, ll mod = md) { return 1ll * a * b % mod; }
inline void cad(ll &a, ll b, ll mod = md) { (a += b) >= mod && (a -= mod); }
inline void csu(ll &a, ll b, ll mod = md) { (a -= b) < 0 && (a += mod); }
inline ll min(ll a, ll b) { return a < b ? a : b; }
inline ll max(ll a, ll b) { return a > b ? a : b; }
inline void cmax(ll &a, ll b) { a = a > b ? a : b; }
inline void cmin(ll &a, ll b) { a = a < b ? a : b; }
inline ll qpow(ll a, ll b, ll mod = md) {
    ll re = 1;
    for (; b; b >>= 1, (a *= a) %= mod) if (b & 1) (re *= a) %= mod;
    return re % mod;
}
#pragma endregion

ll G[2][MAXL], inv[MAXL];
int rev[MAXL];

#pragma region quadratic_residue
ll I;
struct Comp {
    ll a, b;
    Comp(ll _a = 0, ll _b = 0) : a(_a), b(_b) {}
    friend Comp operator*(const Comp &a, const Comp &b) {
        return {(a.a * b.a % md + a.b * b.b % md * I % md + 3ll * md) % md, (a.b * b.a % md + a.a * b.b % md + 3ll * md) % md};
    }
};

bool check(ll n) {
    // ! n 在 mod md 意义下 是二次剩余 等价于 qpow(n, (mod - 1) / 2, mod) == 1
    n %= md;
    return qpow(n, (md - 1) / 2, md) == 1;
}
ll get_qr_ans(Comp t, ll b) {
    Comp re(1, 0);
    for (; b; b >>= 1, t = t * t) if (b & 1) re = re * t;
    return re.a;
}

inline ll quadratic_residue(ll n) {
    //! 求 n 在 mod md 意义下较小的二次剩余 ...
    if (!check(n)) return -1; //* 如果 n 是一个非二次剩余 ... 
    else {
        ll a = rand() % (md - 1) + 1;
        while (check((a * a % md - n % md + 2 * md) % md)) a = rand() % (md - 1) + 1;
        I = (a * a % md - n % md + 2 * md) % md;
        Comp tmp(a, 1);
        ll re = get_qr_ans(tmp, (md + 1) / 2);
        return min(re, md - re);
    }
}
#pragma endregion

#pragma region poly
void preworks() {
    inv[0] = inv[1] = 1;
    for (register int i = 2; i < MAXL; ++ i) inv[i] = (md - md / i) * inv[md % i] % md;

    G[0][0] = G[1][0] = 1;

    G[0][1] = qpow(gen[0], (md - 1) / MAXL), 
        G[1][1] = qpow(gen[1], (md - 1) / MAXL);

    for (register int i = 2; i < MAXL; ++ i) 
        G[0][i] = mul(G[0][i - 1], G[0][1]), 
            G[1][i] = mul(G[1][i - 1], G[1][1]);
}
inline int init(int n) {
    int lim = 1;
    while (lim < n) lim <<= 1;
    for (register int i = 1; i < lim; ++ i) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) * (lim >> 1));
    return lim;
}
inline void ntt(ll *a, int n, int ty) {
    for (register int i = 0; i < n; ++ i) if (i < rev[i]) std::swap(a[i], a[rev[i]]);

    for (register int mid = 1; mid < n; mid <<= 1) 
        for (register int st = 0; st < n; st += (mid << 1))
            for (register int k = 0; k < mid; ++ k) {
                ll x = a[st + k], y = mul(a[st + k + mid], G[ty][MAXL / (mid << 1) * k]);
                a[st + k] = ad(x, y), a[st + k + mid] = su(x, y);
            }

    if (ty) for (register int i = 0; i < n; ++ i) (a[i] *= inv[n]) %= md;
}

struct poly {
    vector<ll> v;
    poly(int n = 0) { v.resize(n); }
    poly(const std::initializer_list<ll> &T) { v = T; }

    int size() const { return v.size(); }

    ll& operator[](int x) { return v[x]; }
    const ll& operator[](const int x) const { return v[x]; }

    void resize(int n) { v.resize(n); }
    void reserve(int n) { v.reserve(n); }
    void reverse() { std::reverse(v.begin(), v.end()); }
    void print() { for (size_t i = 0; i < v.size(); ++ i) printf("%lld%c", v[i], " \n"[i == v.size() - 1]); }
    // void print() { for (size_t i = 0; i < v.size(); ++ i) write(v[i], ' '); }

    friend poly operator*(const poly &lhs, const poly &rhs) {
        static ll t1[MAXL], t2[MAXL];
        int tot = init(lhs.size() + rhs.size()), siz = lhs.size() + rhs.size() - 1;
        poly ret(siz);
        std::memset(t1, 0, tot * sizeof(ll)), std::memset(t2, 0, tot * sizeof(ll));
        for (register int i = 0; i < lhs.size(); ++ i) t1[i] = lhs[i];
        for (register int i = 0; i < rhs.size(); ++ i) t2[i] = rhs[i];
        ntt(t1, tot, 0), ntt(t2, tot, 0);
        for (register int i = 0; i < tot; ++ i) (t1[i] *= t2[i]) %= md;
        ntt(t1, tot, 1);
        for (register int i = 0; i < siz; ++ i) ret[i] = t1[i];
        return ret;
    }
    friend poly operator*(const poly &lhs, const ll &rhs) {
        poly ret(lhs.size());
        for (register int i = 0; i < lhs.size(); ++ i) ret[i] = mul(lhs[i], rhs);
        return ret;
    }
    friend poly convolution(const poly &lhs, const poly &rhs, const std::function<ll(ll, ll)> &calc) {
        static ll t1[MAXL], t2[MAXL];
        int tot = init(lhs.size() + rhs.size()), siz = lhs.size() + rhs.size() - 1;
        poly ret(siz);
        std::memset(t1, 0, tot * sizeof(ll)), std::memset(t2, 0, tot * sizeof(ll));
        for (register int i = 0; i < lhs.size(); ++ i) t1[i] = lhs[i];
        for (register int i = 0; i < rhs.size(); ++ i) t2[i] = rhs[i];
        ntt(t1, tot, 0), ntt(t2, tot, 0);
        for (register int i = 0; i < tot; ++ i) t1[i] = calc(t1[i], t2[i]);
        ntt(t1, tot, 1);
        for (register int i = 0; i < siz; ++ i) ret[i] = t1[i];
        return ret;
    }
    friend poly operator+(const poly &lhs, const poly &rhs) {
        if (lhs.size() > rhs.size()) {
            poly ret(lhs.size());
            for (register int i = 0; i < rhs.size(); ++ i) ret[i] = ad(lhs[i], rhs[i]);
            for (register int i = rhs.size(); i < lhs.size(); ++ i) ret[i] = lhs[i];
            return ret;
        }
        else {
            poly ret(rhs.size());
            for (register int i = 0; i < lhs.size(); ++ i) ret[i] = ad(lhs[i], rhs[i]);
            for (register int i = lhs.size(); i < rhs.size(); ++ i) ret[i] = rhs[i];
            return ret;
        }
    }
    friend poly operator-(const poly &lhs, const poly &rhs) {
        if (lhs.size() > rhs.size()) {
            poly ret(lhs.size());
            for (register int i = 0; i < rhs.size(); ++ i) ret[i] = su(lhs[i], rhs[i]);
            for (register int i = rhs.size(); i < lhs.size(); ++ i) ret[i] = lhs[i];
            return ret;
        }
        else {
            poly ret(rhs.size());
            for (register int i = 0; i < lhs.size(); ++ i) ret[i] = su(lhs[i], rhs[i]);
            for (register int i = lhs.size(); i < rhs.size(); ++ i) ret[i] = su(0, rhs[i]);
            return ret;
        }
    }
    friend poly get_inv(const poly &p) {
        if (p.size() == 1) return poly({qpow(p[0], md - 2)});
        poly tmp = p;
        tmp.resize((p.size() + 1) >> 1);
        poly res = get_inv(tmp);
        res.resize(p.size());
        poly ret = convolution(res, p, [&](ll a, ll b) mutable -> ll { return mul(a, su(2, mul(a, b))); });
        // poly ret = res * 2 - res * res * p;
        ret.resize(p.size());
        return ret;
    }
    friend poly derivation(const poly &p) {
        poly ret(p.size() - 1);
        for (register int i = 0; i < p.size() - 1; ++ i) ret[i] = mul(p[i + 1], i + 1);
        return ret;
    }
    friend poly integral(const poly &p) {
        poly ret(p.size() + 1);
        for (register int i = 1; i < p.size() + 1; ++ i) ret[i] = mul(p[i - 1], inv[i]);
        return ret;
    }
    friend poly ln(const poly &p) {
        poly ret = integral(derivation(p) * get_inv(p));
        ret.resize(p.size());
        return ret;
    }
    friend poly exp(const poly &p) {
        if (p.size() == 1) return poly({1});
        poly tmp = p;
        tmp.resize((p.size() + 1) >> 1);
        poly res = exp(tmp);
        res.resize(p.size());
        poly ret = res * (poly({1}) - ln(res) + p);
        ret.resize(p.size());
        return ret;
    }
    friend poly sqrt(const poly &p) {
        if (p.size() == 1) return poly({quadratic_residue(p[0])});
        poly tmp = p;
        tmp.resize((p.size() + 1) >> 1);
        poly res = sqrt(tmp);
        tmp = res * res;
        res.resize(p.size());
        poly ret = (tmp + p) * get_inv(res * 2);
        ret.resize(p.size());
        return ret;
    }
    friend poly power(const poly &p, int k) { return exp(ln(p) * k); }
    friend poly operator/(const poly &lhs, const poly &rhs) {
        if (lhs.size() < rhs.size()) return poly({0});
        int n = lhs.size(), m = rhs.size();
        poly rf = lhs, rg = rhs;
        rf.reverse(), rg.reverse();
        rf.resize(n - m + 1), rg.resize(n - m + 1);
        poly ret = rf * get_inv(rg);
        ret.resize(n - m + 1);
        ret.reverse();
        return ret;
    }
    friend poly operator%(const poly &lhs, const poly &rhs) {
        if (lhs.size() < rhs.size()) return lhs;
        poly ret = lhs - (lhs / rhs) * rhs;
        ret.resize(rhs.size() - 1);
        return ret;
    }
    friend std::pair<poly, poly> div(const poly &lhs, const poly &rhs) {
        if (lhs.size() < rhs.size()) return {poly({0}), lhs};
        poly ret1 = lhs / rhs;
        poly ret2 = lhs - ret1 * rhs;
        ret2.resize(rhs.size() - 1);
        return {ret1, ret2};
    }
    friend poly ex_exp(const poly &p, ll zero) {
        if (p.size() == 1) return poly({zero});
        poly tmp = p;
        tmp.resize((p.size() + 1) >> 1);
        poly res = ex_exp(tmp, zero);
        res.resize(p.size());
        poly ret = res * (poly({1}) - ln(res) + p);
        ret.resize(p.size());
        return ret;
    }
    friend poly super_power(const poly &p, ll k, ll k2) {
        int cnt = 0;
        for (; cnt < p.size() && !p[cnt]; ++ cnt);
        if (1ll * cnt * k >= p.size()) {
            poly ret(p.size());
            return ret;
        }
        ll inv = qpow(p[cnt], md - 2), v = qpow(p[cnt], k2);
        poly tmp(p.size() - cnt);
        for (register int i = cnt; i < p.size(); ++ i) tmp[i - cnt] = mul(p[i], inv);
        poly res = ln(tmp);
        res.resize(p.size() - 1ll * cnt * k);
        res = res * k;
        poly ret = exp(res);
        for (register int i = p.size() - 1; i >= 1ll * cnt * k; -- i) ret[i] = mul(ret[i - 1ll * cnt * k], v);
        for (register int i = 0; i < 1ll * cnt * k; ++ i) ret[i] = 0;
        ret.resize(p.size());
        return ret;
    }
} f, g;
#pragma endregion poly
 
ll n, k, k2;

inline void readk(char ch = fastio::getchar()) {
    for (; !isdigit(ch); ch = fastio::getchar());
    for (; isdigit(ch); ch = fastio::getchar()) 
        k = (k * 10 + ch - 48) % md, 
            k2 = (k2 * 10 + ch - 48) % (md - 1);
}

signed main() {
    #pragma region local_file
    #ifndef ONLINE_JUDGE
    #ifdef LOCAL
    freopen("e:/.IDE/Vspz/.data/test_data.in", "r", stdin);
    freopen("e:/.IDE/Vspz/.data/test_data.out", "w", stdout);
    #else
    #ifndef GDB
    freopen("base.in", "r", stdin);
    freopen("base.out", "w", stdout);
    #endif
    #endif
    #endif
    #pragma endregion
    
    preworks();
    
    read(n);

    readk();

    f.resize(n);

    for (register int i = 0; i < n; ++ i) read(f[i]);

    g = super_power(f, k, k2);
    g.print();

    #pragma region end
    #ifdef ffileio
        fwrite(pbuf, 1, pp - pbuf, stdout);
    #endif
    #pragma endregion

}
